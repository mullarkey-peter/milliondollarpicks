This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-01T00:36:09.183Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
- Code comments have been removed.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitattributes
.gitignore
auth-service/.gitattributes
auth-service/.gitignore
auth-service/build.gradle
auth-service/Dockerfile
auth-service/gradle/wrapper/gradle-wrapper.properties
auth-service/gradlew
auth-service/gradlew.bat
auth-service/settings.gradle
auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/AuthServiceApplication.java
auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/config/GrpcServerConfig.java
auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/config/SecurityConfig.java
auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/dto/AuthResponseDto.java
auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/dto/CredentialsDto.java
auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/dto/LoginRequestDto.java
auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/dto/UserInfoDto.java
auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/entity/Credentials.java
auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/exception/AuthenticationException.java
auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/exception/GlobalExceptionHandler.java
auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/filter/JwtAuthenticationFilter.java
auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/graphql/AuthResolver.java
auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/graphql/ScalarConfig.java
auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/grpc/AuthGrpcService.java
auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/mapper/CredentialsMapper.java
auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/repository/CredentialsRepository.java
auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/service/AuthService.java
auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/service/AuthServiceImpl.java
auth-service/src/main/proto/auth.proto
auth-service/src/main/resources/application-docker.yml
auth-service/src/main/resources/application.yml
auth-service/src/main/resources/db/migration/V1__init_auth_schema.sql
auth-service/src/main/resources/schema/schema.graphqls
auth-service/src/test/java/com/glizzy/milliondollarpicks/authservice/AuthServiceApplicationTests.java
build.gradle
compose.yaml
Diagrams/MicroserviceArchitecture.puml
Diagrams/UseCases.puml
gradle/wrapper/gradle-wrapper.properties
README.md
repomix-instructions.md
settings.gradle
shared-proto/build.gradle
shared-proto/src/main/proto/auth.proto
src/main/java/com/glizzy/milliondollarpicks/MillionDollarPicksApplication.java
src/main/resources/application.properties
user-service/.gitattributes
user-service/.gitignore
user-service/build.gradle
user-service/Dockerfile
user-service/gradle/wrapper/gradle-wrapper.properties
user-service/gradlew
user-service/gradlew.bat
user-service/settings.gradle
user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/client/AuthServiceClient.java
user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/config/SecurityConfig.java
user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/dto/TokenValidationResultDto.java
user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/dto/UserDto.java
user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/dto/UserInfoDto.java
user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/entity/User.java
user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/exception/DuplicateUserException.java
user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/exception/GlobalExceptionHandler.java
user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/exception/UserNotFoundException.java
user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/filter/JwtAuthenticationFilter.java
user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/graphql/ScalarConfig.java
user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/graphql/UserEntityFetcher.java
user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/graphql/UserResolver.java
user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/mapper/UserMapper.java
user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/repository/UserRepository.java
user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/service/UserService.java
user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/service/UserServiceImpl.java
user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/UserServiceApplication.java
user-service/src/main/resources/application-docker.yml
user-service/src/main/resources/application.yml
user-service/src/main/resources/db/migration/V1__init_user_schema.sql
user-service/src/main/resources/db/migration/V2__update_id_to_bigserial.sql
user-service/src/main/resources/db/migration/V3__remove_password_field.sql
user-service/src/main/resources/schema/schema.graphqls

================================================================
Files
================================================================

================
File: .gitattributes
================
/gradlew text eol=lf
*.bat text eol=crlf
*.jar binary

================
File: .gitignore
================
HELP.md
.gradle
build/
!gradle/wrapper/gradle-wrapper.jar
!**/src/main/**/build/
!**/src/test/**/build/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache
bin/
!**/src/main/**/bin/
!**/src/test/**/bin/

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr
out/
!**/src/main/**/out/
!**/src/test/**/out/

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/

### VS Code ###
.vscode/

================
File: auth-service/.gitattributes
================
/gradlew text eol=lf
*.bat text eol=crlf
*.jar binary

================
File: auth-service/.gitignore
================
HELP.md
.gradle
build/
!gradle/wrapper/gradle-wrapper.jar
!**/src/main/**/build/
!**/src/test/**/build/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache
bin/
!**/src/main/**/bin/
!**/src/test/**/bin/

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr
out/
!**/src/main/**/out/
!**/src/test/**/out/

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/

### VS Code ###
.vscode/

================
File: auth-service/build.gradle
================
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.3'
    id 'io.spring.dependency-management' version '1.1.4'
    id 'com.google.protobuf' version '0.9.4'
}

group = 'com.glizzy'
version = '0.0.1-SNAPSHOT'

java {
    sourceCompatibility = '17'
}

ext {
    set('springCloudVersion', "2023.0.0")
    set('dgsVersion', "8.4.0")
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
    maven { url "https://repo.spring.io/milestone" }
    maven { url "https://repo.spring.io/release" }
}

dependencyManagement {
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
        mavenBom "com.netflix.graphql.dgs:graphql-dgs-platform-dependencies:${dgsVersion}"
    }
}

dependencies {
    // Add dependency to shared-proto module
    implementation project(':shared-proto')

    // Spring Web
    implementation 'org.springframework.boot:spring-boot-starter-web'

    // Spring Security for password encoding
    implementation 'org.springframework.boot:spring-boot-starter-security'

    // JPA Dependencies
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'jakarta.persistence:jakarta.persistence-api:3.1.0'
    implementation 'org.postgresql:postgresql'

    // Flyway for database migrations
    implementation 'org.flywaydb:flyway-core'

    // JWT
    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5'

    // DGS Framework
    implementation platform("com.netflix.graphql.dgs:graphql-dgs-platform-dependencies:${dgsVersion}")
    implementation 'com.netflix.graphql.dgs:graphql-dgs-spring-boot-starter'
    implementation 'com.netflix.graphql.dgs:graphql-dgs-extended-scalars'
    implementation 'com.netflix.graphql.dgs:graphql-dgs-extended-validation'

    // Lombok
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'

    // gRPC
    implementation 'io.grpc:grpc-netty-shaded:1.60.0'
    implementation 'io.grpc:grpc-protobuf:1.60.0'
    implementation 'io.grpc:grpc-stub:1.60.0'
    implementation 'javax.annotation:javax.annotation-api:1.3.2'
}

// Remove the protobuf configuration here since we're using the shared module

================
File: auth-service/Dockerfile
================
# Build stage
FROM gradle:8.5-jdk17 AS build
WORKDIR /app

# Copy the gradle configuration files
COPY settings.gradle .
COPY build.gradle .
COPY shared-proto/build.gradle shared-proto/
COPY auth-service/build.gradle auth-service/

# Copy the shared proto module
COPY shared-proto/src/ shared-proto/src/

# Copy the auth service module
COPY auth-service/src/ auth-service/src/

# Install protoc
RUN apt-get update && apt-get install -y protobuf-compiler

# First build the shared-proto module
RUN gradle :shared-proto:build -x test --no-daemon

# Then build the auth-service module
RUN gradle :auth-service:build -x test --no-daemon

# Run stage
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app
COPY --from=build /app/auth-service/build/libs/*.jar app.jar
ENTRYPOINT ["java","-jar","/app/app.jar"]

================
File: auth-service/gradle/wrapper/gradle-wrapper.properties
================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.12.1-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

================
File: auth-service/gradlew
================
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

================
File: auth-service/gradlew.bat
================
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

================
File: auth-service/settings.gradle
================
rootProject.name = 'auth-service'

================
File: auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/AuthServiceApplication.java
================
package com.glizzy.milliondollarpicks.authservice;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
@SpringBootApplication
@EnableConfigurationProperties
public class AuthServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(AuthServiceApplication.class, args);
    }
}

================
File: auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/config/GrpcServerConfig.java
================
package com.glizzy.milliondollarpicks.authservice.config;
import com.glizzy.milliondollarpicks.authservice.grpc.AuthGrpcService;
import io.grpc.Server;
import io.grpc.ServerBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import java.io.IOException;
@Configuration
public class GrpcServerConfig {
    private static final Logger log = LoggerFactory.getLogger(GrpcServerConfig.class);
    @Value("${grpc.server.port:9090}")
    private int grpcPort;
    private final AuthGrpcService authGrpcService;
    public GrpcServerConfig(AuthGrpcService authGrpcService) {
        this.authGrpcService = authGrpcService;
    }
    @Bean
    public Server grpcServer() throws IOException {
        log.info("Starting gRPC server on port {}", grpcPort);
        Server server = ServerBuilder.forPort(grpcPort)
                .addService(authGrpcService)
                .build();
        server.start();
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            log.info("Shutting down gRPC server");
            if (server != null) {
                server.shutdown();
            }
        }));
        return server;
    }
}

================
File: auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/config/SecurityConfig.java
================
package com.glizzy.milliondollarpicks.authservice.config;
import com.glizzy.milliondollarpicks.authservice.filter.JwtAuthenticationFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/graphql").permitAll()
                        .requestMatchers("/graphiql/**").permitAll()
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    @Bean
    public FilterRegistrationBean<JwtAuthenticationFilter> jwtAuthFilterRegistration() {
        FilterRegistrationBean<JwtAuthenticationFilter> registrationBean = new FilterRegistrationBean<>(jwtAuthenticationFilter);
        registrationBean.setEnabled(false);
        return registrationBean;
    }
}

================
File: auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/dto/AuthResponseDto.java
================
package com.glizzy.milliondollarpicks.authservice.dto;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AuthResponseDto {
    private String token;
    private Long userId;
    private String username;
    private Boolean success;
    private String message;
}

================
File: auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/dto/CredentialsDto.java
================
package com.glizzy.milliondollarpicks.authservice.dto;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CredentialsDto {
    private Long id;
    private String username;
    private Long userId;
    private Boolean accountLocked;
}

================
File: auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/dto/LoginRequestDto.java
================
package com.glizzy.milliondollarpicks.authservice.dto;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LoginRequestDto {
    private String username;
    private String password;
}

================
File: auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/dto/UserInfoDto.java
================
package com.glizzy.milliondollarpicks.authservice.dto;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserInfoDto {
    private String id;
    private String username;
}

================
File: auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/entity/Credentials.java
================
package com.glizzy.milliondollarpicks.authservice.entity;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import jakarta.persistence.Column;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.time.OffsetDateTime;
@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "credentials")
public class Credentials {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(name = "username", unique = true, nullable = false)
    private String username;
    @Column(name = "password_hash", nullable = false)
    private String passwordHash;
    @Column(name = "last_password_change")
    private OffsetDateTime lastPasswordChange;
    @Column(name = "account_locked")
    private Boolean accountLocked;
    @Column(name = "failed_login_attempts")
    private Integer failedLoginAttempts;
    @Column(name = "user_id")
    private Long userId;
}

================
File: auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/exception/AuthenticationException.java
================
package com.glizzy.milliondollarpicks.authservice.exception;
public class AuthenticationException extends RuntimeException {
    public AuthenticationException(String message) {
        super(message);
    }
}

================
File: auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/exception/GlobalExceptionHandler.java
================
package com.glizzy.milliondollarpicks.authservice.exception;
import com.netflix.graphql.dgs.exceptions.DefaultDataFetcherExceptionHandler;
import com.netflix.graphql.types.errors.TypedGraphQLError;
import graphql.execution.DataFetcherExceptionHandlerParameters;
import graphql.execution.DataFetcherExceptionHandlerResult;
import org.jetbrains.annotations.NotNull;
import org.springframework.stereotype.Component;
import java.util.concurrent.CompletableFuture;
@Component
public class GlobalExceptionHandler extends DefaultDataFetcherExceptionHandler {
    @NotNull
    @Override
    public CompletableFuture<DataFetcherExceptionHandlerResult> handleException(DataFetcherExceptionHandlerParameters handlerParameters) {
        Throwable exception = handlerParameters.getException();
        if (exception instanceof AuthenticationException) {
            return CompletableFuture.completedFuture(
                    DataFetcherExceptionHandlerResult.newResult()
                            .error(TypedGraphQLError.newBuilder()
                                    .message(exception.getMessage())
                                    .path(handlerParameters.getPath())
                                    .build())
                            .build()
            );
        }
        return super.handleException(handlerParameters);
    }
}

================
File: auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/filter/JwtAuthenticationFilter.java
================
package com.glizzy.milliondollarpicks.authservice.filter;
import com.glizzy.milliondollarpicks.authservice.service.AuthService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Lazy;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import java.io.IOException;
import java.util.ArrayList;
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private AuthService authService;
    @Value("${jwt.secret}")
    private String jwtSecret;
    @Autowired
    public JwtAuthenticationFilter(@Lazy AuthService authService) {
        this.authService = authService;
    }
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        String authHeader = request.getHeader("Authorization");
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7);
            if (authService.validateToken(token)) {
                Claims claims = Jwts.parserBuilder()
                        .setSigningKey(jwtSecret.getBytes())
                        .build()
                        .parseClaimsJws(token)
                        .getBody();
                String username = claims.getSubject();
                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(username, null, new ArrayList<>());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }
        filterChain.doFilter(request, response);
    }
}

================
File: auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/graphql/AuthResolver.java
================
package com.glizzy.milliondollarpicks.authservice.graphql;
import com.glizzy.milliondollarpicks.authservice.dto.AuthResponseDto;
import com.glizzy.milliondollarpicks.authservice.dto.CredentialsDto;
import com.glizzy.milliondollarpicks.authservice.dto.LoginRequestDto;
import com.glizzy.milliondollarpicks.authservice.dto.UserInfoDto;
import com.glizzy.milliondollarpicks.authservice.service.AuthService;
import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsQuery;
import com.netflix.graphql.dgs.DgsMutation;
import com.netflix.graphql.dgs.InputArgument;
import graphql.schema.DataFetchingEnvironment;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
@DgsComponent
@RequiredArgsConstructor
public class AuthResolver {
    private final AuthService authService;
    private static final Logger log = LoggerFactory.getLogger(AuthResolver.class);
    @Value("${jwt.secret}")
    private String jwtSecret;
    @DgsQuery
    public Boolean validateToken(@InputArgument String token, DataFetchingEnvironment env) {
        log.debug("validateToken called with token parameter present: {}", token != null && !token.isEmpty());
        if (token == null || token.isEmpty()) {
            log.debug("Token is null or empty, attempting to extract from header");
            try {
                token = extractTokenFromHeader(env);
                log.debug("Token extracted from header successfully");
            } catch (Exception e) {
                log.error("Failed to extract token from header: {}", e.getMessage());
                return false;
            }
        }
        boolean isValid = authService.validateToken(token);
        log.debug("Token validation result: {}", isValid);
        return isValid;
    }
    @DgsQuery
    public UserInfoDto me(@InputArgument(name = "token", collectionType = String.class) String token,
                          DataFetchingEnvironment env) {
        log.debug("me query called with token parameter present: {}", token != null && !token.isEmpty());
        try {
            if (token == null || token.isEmpty()) {
                log.debug("Token is null or empty, attempting to extract from header");
                token = extractTokenFromHeader(env);
                log.debug("Token extracted from header: {}", token);
            }
            log.debug("JWT Secret length: {}", jwtSecret != null ? jwtSecret.length() : "null");
            log.debug("Attempting to parse token: {}", token);
            Claims claims = null;
            try {
                claims = Jwts.parserBuilder()
                        .setSigningKey(jwtSecret.getBytes())
                        .build()
                        .parseClaimsJws(token)
                        .getBody();
                log.debug("Successfully parsed token");
            } catch (Exception e) {
                log.error("Error parsing JWT token: {}", e.getMessage(), e);
                throw new RuntimeException("Invalid token - parsing error: " + e.getMessage());
            }
            log.debug("Claims content: {}", claims);
            UserInfoDto userInfo = new UserInfoDto();
            try {
                Object userId = claims.get("userId");
                log.debug("userId from claims (type: {}): {}",
                        userId != null ? userId.getClass().getName() : "null", userId);
                userInfo.setId(userId != null ? String.valueOf(userId) : null);
                log.debug("userId set in userInfo: {}", userInfo.getId());
                String username = claims.get("username", String.class);
                log.debug("username from claims: {}", username);
                userInfo.setUsername(username);
                log.debug("userInfo object created successfully: {}", userInfo);
                return userInfo;
            } catch (Exception e) {
                log.error("Error extracting claims data: {}", e.getMessage(), e);
                throw new RuntimeException("Invalid token - claims extraction error: " + e.getMessage());
            }
        } catch (Exception e) {
            log.error("Unexpected error in me query: {}", e.getMessage(), e);
            throw new RuntimeException("Invalid token: " + e.getMessage());
        }
    }
    @DgsMutation
    public AuthResponseDto login(@InputArgument String username, @InputArgument String password) {
        log.debug("login mutation called for username: {}", username);
        LoginRequestDto loginRequest = new LoginRequestDto(username, password);
        try {
            AuthResponseDto response = authService.login(loginRequest);
            log.debug("Login response: success={}, userId={}", response.getSuccess(), response.getUserId());
            if (response.getSuccess()) {
                log.debug("Generated token length: {}",
                        response.getToken() != null ? response.getToken().length() : "null");
            }
            return response;
        } catch (Exception e) {
            log.error("Error during login: {}", e.getMessage(), e);
            throw e;
        }
    }
    @DgsMutation
    public AuthResponseDto logout(@InputArgument String token, DataFetchingEnvironment env) {
        log.debug("logout mutation called with token parameter present: {}", token != null && !token.isEmpty());
        if (token == null || token.isEmpty()) {
            try {
                token = extractTokenFromHeader(env);
                log.debug("Token extracted from header");
            } catch (Exception e) {
                log.error("Failed to extract token from header: {}", e.getMessage());
                throw e;
            }
        }
        try {
            AuthResponseDto response = authService.logout(token);
            log.debug("Logout successful: {}", response.getSuccess());
            return response;
        } catch (Exception e) {
            log.error("Error during logout: {}", e.getMessage(), e);
            throw e;
        }
    }
    @DgsMutation
    public Boolean resetPassword(@InputArgument String username, @InputArgument String newPassword) {
        log.debug("resetPassword mutation called for username: {}", username);
        try {
            authService.resetPassword(username, newPassword);
            log.debug("Password reset successful for username: {}", username);
            return true;
        } catch (Exception e) {
            log.error("Error resetting password: {}", e.getMessage(), e);
            return false;
        }
    }
    @DgsMutation
    public CredentialsDto createCredentials(
            @InputArgument String username,
            @InputArgument String password,
            @InputArgument String userId) {
        log.debug("createCredentials mutation called for username: {}, userId: {}", username, userId);
        try {
            CredentialsDto credentials = authService.createCredentials(username, password, Long.parseLong(userId));
            log.debug("Credentials created successfully: id={}, userId={}", credentials.getId(), credentials.getUserId());
            return credentials;
        } catch (Exception e) {
            log.error("Error creating credentials: {}", e.getMessage(), e);
            throw e;
        }
    }
    private String extractTokenFromHeader(DataFetchingEnvironment env) {
        log.debug("Attempting to extract token from request header");
        ServletRequestAttributes attributes =
                (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        if (attributes == null) {
            log.error("No request context available");
            throw new RuntimeException("No request context available");
        }
        HttpServletRequest request = attributes.getRequest();
        String authHeader = request.getHeader("Authorization");
        log.debug("Authorization header: {}", authHeader != null ?
                authHeader.substring(0, Math.min(20, authHeader.length())) + "..." : "null");
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7);
            log.debug("Token extracted from header, length: {}", token.length());
            return token;
        }
        log.error("No token provided in the Authorization header");
        throw new RuntimeException("No token provided");
    }
}

================
File: auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/graphql/ScalarConfig.java
================
package com.glizzy.milliondollarpicks.authservice.graphql;
import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsRuntimeWiring;
import graphql.scalars.ExtendedScalars;
import graphql.schema.idl.RuntimeWiring;
@DgsComponent
public class ScalarConfig {
    @DgsRuntimeWiring
    public RuntimeWiring.Builder addScalar(RuntimeWiring.Builder builder) {
        return builder
                .scalar(ExtendedScalars.DateTime)
                .scalar(ExtendedScalars.Object);
    }
}

================
File: auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/grpc/AuthGrpcService.java
================
package com.glizzy.milliondollarpicks.authservice.grpc;
import com.glizzy.milliondollarpicks.authservice.service.AuthService;
import io.grpc.stub.StreamObserver;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import java.util.Optional;
@Service
public class AuthGrpcService extends AuthServiceGrpc.AuthServiceImplBase {
    private final AuthService authService;
    private static final Logger log = LoggerFactory.getLogger(AuthGrpcService.class);
    @Value("${jwt.secret}")
    private String jwtSecret;
    public AuthGrpcService(AuthService authService) {
        this.authService = authService;
    }
    @Override
    public void validateToken(TokenValidationRequest request, StreamObserver<TokenValidationResponse> responseObserver) {
        log.debug("gRPC validateToken called with token length: {}",
                request.getToken() != null ? request.getToken().length() : 0);
        boolean isValid = authService.validateToken(request.getToken());
        TokenValidationResponse response = TokenValidationResponse.newBuilder()
                .setValid(isValid)
                .setMessage(isValid ? "Token is valid" : "Token is invalid or expired")
                .build();
        responseObserver.onNext(response);
        responseObserver.onCompleted();
        log.debug("gRPC validateToken response: {}", response.getValid());
    }
    @Override
    public void getUserInfo(TokenValidationRequest request, StreamObserver<UserInfoResponse> responseObserver) {
        log.debug("gRPC getUserInfo called with token length: {}",
                request.getToken() != null ? request.getToken().length() : 0);
        String token = request.getToken();
        UserInfoResponse.Builder responseBuilder = UserInfoResponse.newBuilder();
        try {
            if (authService.validateToken(token)) {
                Claims claims = Jwts.parserBuilder()
                        .setSigningKey(jwtSecret.getBytes())
                        .build()
                        .parseClaimsJws(token)
                        .getBody();
                Object userId = claims.get("userId");
                String username = claims.get("username", String.class);
                responseBuilder.setUserId(String.valueOf(userId))
                        .setUsername(username)
                        .setSuccess(true)
                        .setMessage("User info retrieved successfully");
            } else {
                responseBuilder.setSuccess(false)
                        .setMessage("Invalid or expired token");
            }
        } catch (Exception e) {
            log.error("Error extracting user info from token: {}", e.getMessage(), e);
            responseBuilder.setSuccess(false)
                    .setMessage("Error processing token: " + e.getMessage());
        }
        UserInfoResponse response = responseBuilder.build();
        responseObserver.onNext(response);
        responseObserver.onCompleted();
        log.debug("gRPC getUserInfo response success: {}", response.getSuccess());
    }
}

================
File: auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/mapper/CredentialsMapper.java
================
package com.glizzy.milliondollarpicks.authservice.mapper;
import com.glizzy.milliondollarpicks.authservice.dto.CredentialsDto;
import com.glizzy.milliondollarpicks.authservice.entity.Credentials;
import org.springframework.stereotype.Component;
@Component
public class CredentialsMapper {
    public CredentialsDto toDto(Credentials credentials) {
        if (credentials == null) {
            return null;
        }
        return CredentialsDto.builder()
                .id(credentials.getId())
                .username(credentials.getUsername())
                .userId(credentials.getUserId())
                .accountLocked(credentials.getAccountLocked())
                .build();
    }
}

================
File: auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/repository/CredentialsRepository.java
================
package com.glizzy.milliondollarpicks.authservice.repository;
import com.glizzy.milliondollarpicks.authservice.entity.Credentials;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;
@Repository
public interface CredentialsRepository extends JpaRepository<Credentials, Long> {
    Optional<Credentials> findByUsername(String username);
    boolean existsByUsername(String username);
}

================
File: auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/service/AuthService.java
================
package com.glizzy.milliondollarpicks.authservice.service;
import com.glizzy.milliondollarpicks.authservice.dto.AuthResponseDto;
import com.glizzy.milliondollarpicks.authservice.dto.CredentialsDto;
import com.glizzy.milliondollarpicks.authservice.dto.LoginRequestDto;
public interface AuthService {
    AuthResponseDto login(LoginRequestDto loginRequest);
    AuthResponseDto logout(String token);
    CredentialsDto createCredentials(String username, String password, Long userId);
    void resetPassword(String username, String newPassword);
    boolean validateToken(String token);
}

================
File: auth-service/src/main/java/com/glizzy/milliondollarpicks/authservice/service/AuthServiceImpl.java
================
package com.glizzy.milliondollarpicks.authservice.service;
import com.glizzy.milliondollarpicks.authservice.dto.AuthResponseDto;
import com.glizzy.milliondollarpicks.authservice.dto.CredentialsDto;
import com.glizzy.milliondollarpicks.authservice.dto.LoginRequestDto;
import com.glizzy.milliondollarpicks.authservice.entity.Credentials;
import com.glizzy.milliondollarpicks.authservice.exception.AuthenticationException;
import com.glizzy.milliondollarpicks.authservice.mapper.CredentialsMapper;
import com.glizzy.milliondollarpicks.authservice.repository.CredentialsRepository;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.security.Key;
import java.time.OffsetDateTime;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
@Service
@RequiredArgsConstructor
@Transactional
public class AuthServiceImpl implements AuthService {
    private final CredentialsRepository credentialsRepository;
    private final CredentialsMapper credentialsMapper;
    private final PasswordEncoder passwordEncoder;
    @Value("${jwt.secret}")
    private String jwtSecret;
    @Value("${jwt.expiration}")
    private long jwtExpiration;
    private Key getSigningKey() {
        return Keys.hmacShaKeyFor(jwtSecret.getBytes());
    }
    @Override
    public AuthResponseDto login(LoginRequestDto loginRequest) {
        Credentials credentials = credentialsRepository.findByUsername(loginRequest.getUsername())
                .orElseThrow(() -> new AuthenticationException("Invalid username or password"));
        if (credentials.getAccountLocked()) {
            return AuthResponseDto.builder()
                    .success(false)
                    .message("Account is locked")
                    .build();
        }
        if (!passwordEncoder.matches(loginRequest.getPassword(), credentials.getPasswordHash())) {
            credentials.setFailedLoginAttempts(credentials.getFailedLoginAttempts() + 1);
            if (credentials.getFailedLoginAttempts() >= 5) {
                credentials.setAccountLocked(true);
            }
            credentialsRepository.save(credentials);
            throw new AuthenticationException("Invalid username or password");
        }
        credentials.setFailedLoginAttempts(0);
        credentialsRepository.save(credentials);
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", credentials.getUserId());
        claims.put("username", credentials.getUsername());
        String token = Jwts.builder()
                .setClaims(claims)
                .setSubject(credentials.getUsername())
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + jwtExpiration))
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
        return AuthResponseDto.builder()
                .token(token)
                .userId(credentials.getUserId())
                .username(credentials.getUsername())
                .success(true)
                .build();
    }
    @Override
    public AuthResponseDto logout(String token) {
        return AuthResponseDto.builder()
                .success(true)
                .message("Logged out successfully")
                .build();
    }
    @Override
    public CredentialsDto createCredentials(String username, String password, Long userId) {
        if (credentialsRepository.existsByUsername(username)) {
            throw new AuthenticationException("Username already exists");
        }
        Credentials credentials = new Credentials();
        credentials.setUsername(username);
        credentials.setPasswordHash(passwordEncoder.encode(password));
        credentials.setLastPasswordChange(OffsetDateTime.now());
        credentials.setAccountLocked(false);
        credentials.setFailedLoginAttempts(0);
        credentials.setUserId(userId);
        Credentials savedCredentials = credentialsRepository.save(credentials);
        return credentialsMapper.toDto(savedCredentials);
    }
    @Override
    public void resetPassword(String username, String newPassword) {
        Credentials credentials = credentialsRepository.findByUsername(username)
                .orElseThrow(() -> new AuthenticationException("User not found"));
        credentials.setPasswordHash(passwordEncoder.encode(newPassword));
        credentials.setLastPasswordChange(OffsetDateTime.now());
        credentials.setFailedLoginAttempts(0);
        credentials.setAccountLocked(false);
        credentialsRepository.save(credentials);
    }
    @Override
    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                    .setSigningKey(getSigningKey())
                    .build()
                    .parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}

================
File: auth-service/src/main/proto/auth.proto
================
syntax = "proto3";

option java_multiple_files = true;
option java_package = "com.glizzy.milliondollarpicks.authservice.grpc";
option java_outer_classname = "AuthProto";

package auth;

// Authentication service definition
service AuthService {
  // Validate a JWT token
  rpc ValidateToken (TokenValidationRequest) returns (TokenValidationResponse) {}

  // Get user info from token
  rpc GetUserInfo (TokenValidationRequest) returns (UserInfoResponse) {}
}

// The request message containing the token to validate
message TokenValidationRequest {
  string token = 1;
}

// The response message containing the validation result
message TokenValidationResponse {
  bool valid = 1;
  string message = 2;
}

// The response message containing user information
message UserInfoResponse {
  string user_id = 1;
  string username = 2;
  bool success = 3;
  string message = 4;
}

================
File: auth-service/src/main/resources/application-docker.yml
================
spring:
  datasource:
    url: jdbc:postgresql://postgres:5432/authdb
    username: ${SPRING_DATASOURCE_USERNAME:postgres}
    password: ${SPRING_DATASOURCE_PASSWORD:postgres}
    driver-class-name: org.postgresql.Driver
  jpa:
    hibernate:
      ddl-auto: validate
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true
    show-sql: true
  flyway:
    url: ${SPRING_FLYWAY_URL:jdbc:postgresql://postgres:5432/authdb}
    user: ${SPRING_FLYWAY_USER:postgres}
    password: ${SPRING_FLYWAY_PASSWORD:postgres}
    baseline-on-migrate: true
    locations: classpath:db/migration
logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql: TRACE
    com.glizzy.milliondollarpicks: DEBUG
    org.springframework.boot: INFO
grpc:
  server:
    port: 9090

================
File: auth-service/src/main/resources/application.yml
================
spring:
  datasource:
    url: jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:authdb}
    username: ${DB_USERNAME:postgres}
    password: ${DB_PASSWORD:postgres}
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: true
    properties:
      hibernate:
        format_sql: true
  flyway:
    baseline-on-migrate: true
    locations: classpath:db/migration
dgs:
  graphql:
    enabled: true
    context:
      builder-enabled: true
  graphiql:
    enabled: true
    path: /graphiql
jwt:
  secret: ${JWT_SECRET:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6a7b8c9d0}
  expiration: ${JWT_EXPIRATION:86400000}
logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql: TRACE
    com.glizzy.milliondollarpicks: DEBUG
grpc:
  server:
    port: 9090

================
File: auth-service/src/main/resources/db/migration/V1__init_auth_schema.sql
================
CREATE TABLE IF NOT EXISTS credentials (
                                           id BIGSERIAL PRIMARY KEY,
                                           username VARCHAR(50) NOT NULL UNIQUE,
                                           password_hash VARCHAR(255) NOT NULL,
                                           last_password_change TIMESTAMP WITH TIME ZONE,
                                           account_locked BOOLEAN DEFAULT FALSE,
                                           failed_login_attempts INTEGER DEFAULT 0,
                                           user_id BIGINT NOT NULL
);
CREATE INDEX idx_credentials_username ON credentials(username);
CREATE INDEX idx_credentials_user_id ON credentials(user_id);

================
File: auth-service/src/main/resources/schema/schema.graphqls
================
scalar DateTime

type Query {
    validateToken(token: String): Boolean
    me(token: String): UserInfo
}

type Mutation {
    login(username: String!, password: String!): AuthResponse
    logout(token: String!): AuthResponse
    resetPassword(username: String!, newPassword: String!): Boolean
    createCredentials(username: String!, password: String!, userId: ID!): Credentials
}

type AuthResponse {
    token: String
    userId: ID
    username: String
    success: Boolean!
    message: String
}

type Credentials {
    id: ID!
    username: String!
    userId: ID!
    accountLocked: Boolean
}

# Instead of UserReference with @key directive, use a local type
type UserInfo {
    id: ID!
    username: String!
}

# Keep this commented for later federation use
# type UserReference @key(fields: "id") {
#     id: ID!
#     username: String!
# }

================
File: auth-service/src/test/java/com/glizzy/milliondollarpicks/authservice/AuthServiceApplicationTests.java
================
package com.glizzy.milliondollarpicks.authservice;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
@SpringBootTest
class AuthServiceApplicationTests {
    @Test
    void contextLoads() {
    }
}

================
File: build.gradle
================
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.3'
    id 'io.spring.dependency-management' version '1.1.4'
}

repositories {
    mavenCentral()
    maven { url "https://repo.spring.io/milestone" }
    maven { url "https://repo.spring.io/release" }
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter'
    developmentOnly 'org.springframework.boot:spring-boot-docker-compose'
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'org.springframework.boot'
    apply plugin: 'io.spring.dependency-management'

    group = 'com.glizzy'
    version = '0.0.1-SNAPSHOT'

    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(17)
        }
    }

    configurations {
        compileOnly {
            extendsFrom annotationProcessor
        }
    }

    // Common dependencies that might be shared across services
    dependencies {
        compileOnly 'org.projectlombok:lombok'
        annotationProcessor 'org.projectlombok:lombok'
        developmentOnly 'org.springframework.boot:spring-boot-devtools'
        developmentOnly 'org.springframework.boot:spring-boot-docker-compose'
    }

    test {
        useJUnitPlatform()
    }
}

================
File: compose.yaml
================
services:
  userdb:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=userdb
    ports:
      - "5433:5432"
    volumes:
      - userdb_data:/var/lib/postgresql/data
      - ./docker-postgresql-init/userdb:/docker-entrypoint-initdb.d
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d userdb"]
      interval: 10s
      timeout: 5s
      retries: 5
    command: postgres -c 'max_connections=200'
  authdb:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=authdb
    ports:
      - "5434:5432"
    volumes:
      - authdb_data:/var/lib/postgresql/data
      - ./docker-postgresql-init/authdb:/docker-entrypoint-initdb.d
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d authdb"]
      interval: 10s
      timeout: 5s
      retries: 5
    command: postgres -c 'max_connections=200'
  user-service:
    build:
      context: .
      dockerfile: user-service/Dockerfile
    container_name: user-service
    ports:
      - "8081:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - SPRING_DATASOURCE_URL=jdbc:postgresql://userdb:5432/userdb
      - SPRING_DATASOURCE_USERNAME=postgres
      - SPRING_DATASOURCE_PASSWORD=postgres
      - SPRING_FLYWAY_URL=jdbc:postgresql://userdb:5432/userdb
      - SPRING_FLYWAY_USER=postgres
      - SPRING_FLYWAY_PASSWORD=postgres
      - JWT_SECRET=a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6a7b8c9d0
      - JWT_EXPIRATION=86400000
    depends_on:
      userdb:
        condition: service_healthy
  auth-service:
    build:
      context: .
      dockerfile: auth-service/Dockerfile
    container_name: auth-service
    ports:
      - "8082:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - SPRING_DATASOURCE_URL=jdbc:postgresql://authdb:5432/authdb
      - SPRING_DATASOURCE_USERNAME=postgres
      - SPRING_DATASOURCE_PASSWORD=postgres
      - SPRING_FLYWAY_URL=jdbc:postgresql://authdb:5432/authdb
      - SPRING_FLYWAY_USER=postgres
      - SPRING_FLYWAY_PASSWORD=postgres
      - JWT_SECRET=a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6a7b8c9d0
      - JWT_EXPIRATION=86400000
    depends_on:
      authdb:
        condition: service_healthy
volumes:
  userdb_data:
    driver: local
  authdb_data:
    driver: local

================
File: Diagrams/MicroserviceArchitecture.puml
================
@startuml

' Define the diagram layout
top to bottom direction
skinparam componentStyle rectangle

' Define node types
skinparam rectangle {
  BackgroundColor<<Client>> LightBlue
  BorderColor<<Client>> DarkBlue
}

skinparam rectangle {
  BackgroundColor<<Service>> LightGreen
  BorderColor<<Service>> DarkGreen
}

skinparam database {
  BackgroundColor LightYellow
  BorderColor DarkOrange
}

' Client Applications
rectangle "Mobile App" as MobileApp <<Client>>
rectangle "Web App" as WebApp <<Client>>
rectangle "3rd Party App" as ThirdPartyApp <<Client>>

' API Gateway
rectangle "GraphQL Federation Gateway" as Gateway

' Internal Services
rectangle "User Service\n(Spring + DGS)" as UserService <<Service>>
rectangle "Event Service\n(Spring + DGS)" as EventService <<Service>>
rectangle "Prediction Service\n(Spring + DGS)" as PredictionService <<Service>>
rectangle "Betting Service\n(Spring + DGS)" as BettingService <<Service>>
rectangle "Notification Service\n(Spring + DGS)" as NotificationService <<Service>>
rectangle "Reporting Service\n(Spring + DGS)" as ReportingService <<Service>>

' Data Storage
database "User DB" as UserDB
database "Event DB" as EventDB
database "Prediction DB" as PredictionDB
database "Betting DB" as BettingDB
database "Notification DB" as NotificationDB
database "Reporting DB" as ReportingDB

' Message Broker
rectangle "Apache Kafka" as Kafka

' External API connections (GraphQL)
MobileApp -down-> Gateway : GraphQL
WebApp -down-> Gateway : GraphQL
ThirdPartyApp -down-> Gateway : GraphQL

Gateway -down-> UserService : GraphQL\nFederation
Gateway -down-> EventService : GraphQL\nFederation
Gateway -down-> PredictionService : GraphQL\nFederation
Gateway -down-> BettingService : GraphQL\nFederation
Gateway -down-> NotificationService : GraphQL\nFederation
Gateway -down-> ReportingService : GraphQL\nFederation

' Service to DB connections
UserService -down-> UserDB : R2DBC
EventService -down-> EventDB : R2DBC
PredictionService -down-> PredictionDB : R2DBC
BettingService -down-> BettingDB : R2DBC
NotificationService -down-> NotificationDB : Reactive MongoDB
ReportingService -down-> ReportingDB : R2DBC

' Kafka connections
UserService -down-> Kafka : Pub/Sub
EventService -down-> Kafka : Pub/Sub
PredictionService -down-> Kafka : Pub/Sub
BettingService -down-> Kafka : Pub/Sub
Kafka -up-> NotificationService : Consume
Kafka -up-> ReportingService : Consume

' gRPC connections (using dashed lines)
PredictionService ...> EventService : gRPC
BettingService ...> PredictionService : gRPC
BettingService ...> UserService : gRPC
NotificationService ...> UserService : gRPC
ReportingService ...> UserService : gRPC
ReportingService ...> EventService : gRPC
ReportingService ...> PredictionService : gRPC
ReportingService ...> BettingService : gRPC

@enduml

================
File: Diagrams/UseCases.puml
================
@startuml
' Define the system boundary
rectangle "Million Dollar Picks System" {
  ' User use cases
  usecase "Register Account" as UC1
  usecase "Login" as UC2
  usecase "Logout" as UC2a
  usecase "View Predictions" as UC3
  usecase "Track Betting History" as UC4
  usecase "Receive Notifications" as UC5

  ' New betting use cases
  usecase "Place Bet" as UC7
  usecase "View Available Betting Options" as UC8
  usecase "Set Betting Limits" as UC9
  usecase "Cancel Bet" as UC10
  usecase "View Current Balance" as UC11


}

' Define actors
actor "User" as User
actor "Authentication Service" as AuthService
actor "User Service" as UserService
actor "Betting Service" as BettingService

' Define relationships
User --> UC1
User --> UC2
User --> UC2a
User --> UC3
User --> UC4
User --> UC5

' New betting relationships
User --> UC7
User --> UC8

UC7 ..> BettingService : includes
UC8 ..> BettingService : includes
UC9 ..> BettingService : includes
UC10 ..> BettingService : includes
UC11 ..> BettingService : includes

AuthService --> UC2
AuthService --> UC2a
UC1 ..> UserService : includes
UC2 ..> AuthService : includes
UC2a ..> AuthService : includes

@enduml

================
File: gradle/wrapper/gradle-wrapper.properties
================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.12.1-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

================
File: README.md
================
# Project Title

Million Dollar Picks is an application to allow users to compete using fake money based off of Bill Simmons weekly segment on his podcast.


## Acknowledgements

 - [Awesome Readme Templates](https://awesomeopensource.com/project/elangosundar/awesome-README-templates)
 - [Awesome README](https://github.com/matiassingers/awesome-readme)
 - [How to write a Good readme](https://bulldogjob.com/news/449-how-to-write-a-good-readme-for-your-github-project)


## API Reference

#### Get all items

```http
  GET /api/items
```

| Parameter | Type     | Description                |
| :-------- | :------- | :------------------------- |
| `api_key` | `string` | **Required**. Your API key |

#### Get item

```http
  GET /api/items/${id}
```

| Parameter | Type     | Description                       |
| :-------- | :------- | :-------------------------------- |
| `id`      | `string` | **Required**. Id of item to fetch |

#### add(num1, num2)

Takes two numbers and returns the sum.


## Authors

- [@mullarkey-peter](https://www.github.com/octokatherine)


## Deployment

To deploy this project run

```bash
  npm run deploy
```


## Environment Variables

To run this project, you will need to add the following environment variables to your .env file

`API_KEY`

`ANOTHER_API_KEY`


## Documentation

[Documentation](https://linktodocumentation)


## Run Locally

Clone the project

```bash
  git clone https://link-to-project
```

Go to the project directory

```bash
  cd my-project
```

Install dependencies

```bash
  npm install
```

Start the server

```bash
  npm run start
```


## Demo

Insert gif or link to demo

================
File: repomix-instructions.md
================
{
    "output": {
        "instructionFilePath": "repomix-instruction.md",
        "removeComments": true
    }
}

================
File: settings.gradle
================
// settings.gradle
rootProject.name = 'million-dollar-picks'

include 'user-service'
include 'auth-service'
include 'shared-proto'

================
File: shared-proto/build.gradle
================
plugins {
    id 'java'
    id 'com.google.protobuf' version '0.9.4'
}

group = 'com.glizzy'
version = '0.0.1-SNAPSHOT'

java {
    sourceCompatibility = '17'
}

repositories {
    mavenCentral()
}

dependencies {
    // gRPC
    implementation 'io.grpc:grpc-netty-shaded:1.60.0'
    implementation 'io.grpc:grpc-protobuf:1.60.0'
    implementation 'io.grpc:grpc-stub:1.60.0'
    implementation 'javax.annotation:javax.annotation-api:1.3.2'
}

protobuf {
    protoc {
        artifact = "com.google.protobuf:protoc:3.25.1"
    }
    plugins {
        grpc {
            artifact = "io.grpc:protoc-gen-grpc-java:1.60.0"
        }
    }
    generateProtoTasks {
        all()*.plugins {
            grpc {}
        }
    }
}

// Make sure the generated Java files are properly included in the jar
sourceSets {
    main {
        java {
            srcDirs 'build/generated/source/proto/main/grpc'
            srcDirs 'build/generated/source/proto/main/java'
        }
    }
}

// Exclude bootJar task as shared-proto is a library
tasks.named('bootJar') {
    enabled = false
}

================
File: shared-proto/src/main/proto/auth.proto
================
syntax = "proto3";

option java_multiple_files = true;
option java_package = "com.glizzy.milliondollarpicks.authservice.grpc";
option java_outer_classname = "AuthProto";

package auth;

// Authentication service definition
service AuthService {
  // Validate a JWT token
  rpc ValidateToken (TokenValidationRequest) returns (TokenValidationResponse) {}

  // Get user info from token
  rpc GetUserInfo (TokenValidationRequest) returns (UserInfoResponse) {}
}

// The request message containing the token to validate
message TokenValidationRequest {
  string token = 1;
}

// The response message containing the validation result
message TokenValidationResponse {
  bool valid = 1;
  string message = 2;
}

// The response message containing user information
message UserInfoResponse {
  string user_id = 1;
  string username = 2;
  bool success = 3;
  string message = 4;
}

================
File: src/main/java/com/glizzy/milliondollarpicks/MillionDollarPicksApplication.java
================
package com.glizzy.milliondollarpicks;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
@SpringBootApplication
@EnableConfigurationProperties
public class MillionDollarPicksApplication {
    public static void main(String[] args) {
        SpringApplication.run(MillionDollarPicksApplication.class, args);
    }
}

================
File: src/main/resources/application.properties
================
spring.application.name=MillionDollarPicks

================
File: user-service/.gitattributes
================
/gradlew text eol=lf
*.bat text eol=crlf
*.jar binary

================
File: user-service/.gitignore
================
HELP.md
.gradle
build/
!gradle/wrapper/gradle-wrapper.jar
!**/src/main/**/build/
!**/src/test/**/build/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache
bin/
!**/src/main/**/bin/
!**/src/test/**/bin/

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr
out/
!**/src/main/**/out/
!**/src/test/**/out/

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/

### VS Code ###
.vscode/

================
File: user-service/build.gradle
================
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.3'
    id 'io.spring.dependency-management' version '1.1.4'
}

group = 'com.glizzy'
version = '0.0.1-SNAPSHOT'

java {
    sourceCompatibility = '17'
}

ext {
    set('springCloudVersion', "2023.0.0")
    set('dgsVersion', "8.4.0")
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
    maven { url "https://repo.spring.io/milestone" }
    maven { url "https://repo.spring.io/release" }
}

dependencyManagement {
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
        mavenBom "com.netflix.graphql.dgs:graphql-dgs-platform-dependencies:${dgsVersion}"
    }
}

dependencies {
    // Add dependency to shared-proto module
    implementation project(':shared-proto')

    // Spring Web (Servlet)
    implementation 'org.springframework.boot:spring-boot-starter-web'

    // JPA Dependencies
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'jakarta.persistence:jakarta.persistence-api:3.1.0'
    implementation 'org.postgresql:postgresql'

    // Flyway for database migrations
    implementation 'org.flywaydb:flyway-core'

    // DGS Framework
    implementation platform("com.netflix.graphql.dgs:graphql-dgs-platform-dependencies:${dgsVersion}")
    implementation 'com.netflix.graphql.dgs:graphql-dgs-spring-boot-starter'
    implementation 'com.netflix.graphql.dgs:graphql-dgs-extended-scalars'

    // Lombok
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'

    // gRPC
    implementation 'io.grpc:grpc-netty-shaded:1.60.0'
    implementation 'io.grpc:grpc-protobuf:1.60.0'
    implementation 'io.grpc:grpc-stub:1.60.0'
    implementation 'javax.annotation:javax.annotation-api:1.3.2'
}

// Remove the protobuf configuration here since we're using the shared module

================
File: user-service/Dockerfile
================
# Build stage
FROM gradle:8.5-jdk17 AS build
WORKDIR /app

# Copy the gradle configuration files
COPY settings.gradle .
COPY build.gradle .
COPY shared-proto/build.gradle shared-proto/
COPY user-service/build.gradle user-service/

# Copy the shared proto module
COPY shared-proto/src/ shared-proto/src/

# Copy the user service module
COPY user-service/src/ user-service/src/

# Install protoc
RUN apt-get update && apt-get install -y protobuf-compiler

# First build the shared-proto module
RUN gradle :shared-proto:build -x test --no-daemon

# Then build the user-service module
RUN gradle :user-service:build -x test --no-daemon

# Run stage
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app
COPY --from=build /app/user-service/build/libs/*.jar app.jar
ENTRYPOINT ["java","-jar","/app/app.jar"]

================
File: user-service/gradle/wrapper/gradle-wrapper.properties
================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.10-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

================
File: user-service/gradlew
================
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

================
File: user-service/gradlew.bat
================
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

================
File: user-service/settings.gradle
================
plugins {
    id 'org.gradle.toolchains.foojay-resolver-convention' version '0.5.0' // or latest version
}

rootProject.name = 'user-service'

================
File: user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/client/AuthServiceClient.java
================
package com.glizzy.milliondollarpicks.userservice.client;
import com.glizzy.milliondollarpicks.userservice.dto.TokenValidationResultDto;
import com.glizzy.milliondollarpicks.userservice.dto.UserInfoDto;
import com.glizzy.milliondollarpicks.authservice.grpc.AuthServiceGrpc;
import com.glizzy.milliondollarpicks.authservice.grpc.TokenValidationRequest;
import com.glizzy.milliondollarpicks.authservice.grpc.TokenValidationResponse;
import com.glizzy.milliondollarpicks.authservice.grpc.UserInfoResponse;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.StatusRuntimeException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.util.concurrent.TimeUnit;
@Component
public class AuthServiceClient {
    private static final Logger log = LoggerFactory.getLogger(AuthServiceClient.class);
    @Value("${grpc.client.auth-service.host:auth-service}")
    private String authServiceHost;
    @Value("${grpc.client.auth-service.port:9090}")
    private int authServicePort;
    private ManagedChannel channel;
    private AuthServiceGrpc.AuthServiceBlockingStub blockingStub;
    @PostConstruct
    public void init() {
        log.info("Initializing gRPC client to auth-service at {}:{}", authServiceHost, authServicePort);
        channel = ManagedChannelBuilder.forAddress(authServiceHost, authServicePort)
                .usePlaintext()
                .build();
        blockingStub = AuthServiceGrpc.newBlockingStub(channel);
    }
    @PreDestroy
    public void shutdown() {
        log.info("Shutting down gRPC client");
        if (channel != null) {
            try {
                channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                log.error("Error shutting down gRPC channel: {}", e.getMessage());
            }
        }
    }
    public TokenValidationResultDto validateToken(String token) {
        log.debug("Calling auth-service to validate token");
        try {
            TokenValidationRequest request = TokenValidationRequest.newBuilder()
                    .setToken(token)
                    .build();
            TokenValidationResponse response = blockingStub.validateToken(request);
            log.debug("Token validation response: valid={}", response.getValid());
            return new TokenValidationResultDto(response.getValid(), response.getMessage());
        } catch (StatusRuntimeException e) {
            log.error("RPC failed: {}", e.getStatus(), e);
            return new TokenValidationResultDto(false, "RPC Error: " + e.getStatus());
        }
    }
    public UserInfoDto getUserInfo(String token) {
        log.debug("Calling auth-service to get user info from token");
        try {
            TokenValidationRequest request = TokenValidationRequest.newBuilder()
                    .setToken(token)
                    .build();
            UserInfoResponse response = blockingStub.getUserInfo(request);
            log.debug("User info response: success={}, userId={}", response.getSuccess(), response.getUserId());
            if (response.getSuccess()) {
                return new UserInfoDto(response.getUserId(), response.getUsername());
            } else {
                log.warn("Failed to get user info: {}", response.getMessage());
                return null;
            }
        } catch (StatusRuntimeException e) {
            log.error("RPC failed: {}", e.getStatus(), e);
            return null;
        }
    }
}

================
File: user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/config/SecurityConfig.java
================
package com.glizzy.milliondollarpicks.userservice.config;
import com.glizzy.milliondollarpicks.userservice.filter.JwtAuthenticationFilter;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
@Configuration
public class SecurityConfig {
    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }
    @Bean
    public FilterRegistrationBean<JwtAuthenticationFilter> jwtFilterRegistration() {
        FilterRegistrationBean<JwtAuthenticationFilter> registrationBean = new FilterRegistrationBean<>();
        registrationBean.setFilter(jwtAuthenticationFilter);
        registrationBean.addUrlPatterns("/graphql/*");
        return registrationBean;
    }
}

================
File: user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/dto/TokenValidationResultDto.java
================
package com.glizzy.milliondollarpicks.userservice.dto;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
@Data
@NoArgsConstructor
@AllArgsConstructor
public class TokenValidationResultDto {
    private boolean valid;
    private String message;
}

================
File: user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/dto/UserDto.java
================
package com.glizzy.milliondollarpicks.userservice.dto;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import java.time.OffsetDateTime;
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserDto {
    private Long id;
    private String username;
    private OffsetDateTime registrationDate;
    private OffsetDateTime lastLoginDate;
}

================
File: user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/dto/UserInfoDto.java
================
package com.glizzy.milliondollarpicks.userservice.dto;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserInfoDto {
    private String id;
    private String username;
}

================
File: user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/entity/User.java
================
package com.glizzy.milliondollarpicks.userservice.entity;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import jakarta.persistence.Column;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.time.OffsetDateTime;
@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(name = "username", unique = true, nullable = false)
    private String username;
    @Column(name = "registration_date")
    private OffsetDateTime registrationDate;
    @Column(name = "last_login_date")
    private OffsetDateTime lastLoginDate;
}

================
File: user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/exception/DuplicateUserException.java
================
package com.glizzy.milliondollarpicks.userservice.exception;
public class DuplicateUserException extends RuntimeException {
    public DuplicateUserException(String message) {
        super(message);
    }
}

================
File: user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/exception/GlobalExceptionHandler.java
================
package com.glizzy.milliondollarpicks.userservice.exception;
import com.netflix.graphql.dgs.exceptions.DefaultDataFetcherExceptionHandler;
import com.netflix.graphql.types.errors.TypedGraphQLError;
import graphql.execution.DataFetcherExceptionHandlerParameters;
import graphql.execution.DataFetcherExceptionHandlerResult;
import org.jetbrains.annotations.NotNull;
import org.springframework.stereotype.Component;
import java.util.concurrent.CompletableFuture;
@Component
public class GlobalExceptionHandler extends DefaultDataFetcherExceptionHandler {
    @NotNull
    @Override
    public CompletableFuture<DataFetcherExceptionHandlerResult> handleException(DataFetcherExceptionHandlerParameters handlerParameters) {
        Throwable exception = handlerParameters.getException();
        if (exception instanceof UserNotFoundException) {
            return CompletableFuture.completedFuture(
                DataFetcherExceptionHandlerResult.newResult()
                    .error(TypedGraphQLError.newBuilder()
                        .message(exception.getMessage())
                        .path(handlerParameters.getPath())
                        .build())
                    .build()
            );
        }
        if (exception instanceof DuplicateUserException) {
            return CompletableFuture.completedFuture(
                DataFetcherExceptionHandlerResult.newResult()
                    .error(TypedGraphQLError.newBuilder()
                        .message(exception.getMessage())
                        .path(handlerParameters.getPath())
                        .build())
                    .build()
            );
        }
        return super.handleException(handlerParameters);
    }
}

================
File: user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/exception/UserNotFoundException.java
================
package com.glizzy.milliondollarpicks.userservice.exception;
public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}

================
File: user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/filter/JwtAuthenticationFilter.java
================
package com.glizzy.milliondollarpicks.userservice.filter;
import com.glizzy.milliondollarpicks.userservice.client.AuthServiceClient;
import com.glizzy.milliondollarpicks.userservice.dto.TokenValidationResultDto;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import java.io.IOException;
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private static final Logger log = LoggerFactory.getLogger(JwtAuthenticationFilter.class);
    private final AuthServiceClient authServiceClient;
    public JwtAuthenticationFilter(AuthServiceClient authServiceClient) {
        this.authServiceClient = authServiceClient;
    }
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        String path = request.getRequestURI();
        if (path.contains("/graphiql")) {
            filterChain.doFilter(request, response);
            return;
        }
        String authHeader = request.getHeader("Authorization");
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7);
            log.debug("Validating token from request");
            TokenValidationResultDto validationResult = authServiceClient.validateToken(token);
            if (validationResult.isValid()) {
                log.debug("Token is valid, proceeding with request");
                filterChain.doFilter(request, response);
            } else {
                log.warn("Invalid token: {}", validationResult.getMessage());
                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                response.getWriter().write("Unauthorized: " + validationResult.getMessage());
            }
        } else {
            if (path.equals("/graphql") && isAuthenticationRequired(request)) {
                log.warn("Missing Authorization header for GraphQL request");
                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                response.getWriter().write("Unauthorized: Missing or invalid token");
            } else {
                filterChain.doFilter(request, response);
            }
        }
    }
    private boolean isAuthenticationRequired(HttpServletRequest request) {
        try {
            String body = request.getReader().lines().reduce("", (accumulator, actual) -> accumulator + actual);
            return body.contains("mutation");
        } catch (IOException e) {
            log.error("Error reading request body", e);
            return false;
        }
    }
}

================
File: user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/graphql/ScalarConfig.java
================
package com.glizzy.milliondollarpicks.userservice.graphql;
import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsRuntimeWiring;
import graphql.scalars.ExtendedScalars;
import graphql.schema.idl.RuntimeWiring;
@DgsComponent
public class ScalarConfig {
    @DgsRuntimeWiring
    public RuntimeWiring.Builder addScalar(RuntimeWiring.Builder builder) {
        return builder
                .scalar(ExtendedScalars.DateTime)
                .scalar(ExtendedScalars.Object);
    }
}

================
File: user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/graphql/UserEntityFetcher.java
================
package com.glizzy.milliondollarpicks.userservice.graphql;
import com.glizzy.milliondollarpicks.userservice.dto.UserDto;
import com.glizzy.milliondollarpicks.userservice.service.UserService;
import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsEntityFetcher;
import lombok.RequiredArgsConstructor;
import java.util.Map;
@DgsComponent
@RequiredArgsConstructor
public class UserEntityFetcher {
    private final UserService userService;
    @DgsEntityFetcher(name = "User")
    public UserDto fetchUserById(Map<String, Object> values) {
        String id = (String) values.get("id");
        return userService.findUserById(Long.parseLong(id));
    }
}

================
File: user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/graphql/UserResolver.java
================
package com.glizzy.milliondollarpicks.userservice.graphql;
import com.glizzy.milliondollarpicks.userservice.dto.UserDto;
import com.glizzy.milliondollarpicks.userservice.service.UserService;
import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsQuery;
import com.netflix.graphql.dgs.DgsMutation;
import com.netflix.graphql.dgs.InputArgument;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
@DgsComponent
@RequiredArgsConstructor
public class UserResolver {
    private final UserService userService;
    private static final Logger log = LoggerFactory.getLogger(UserResolver.class);
    @DgsQuery
    public UserDto userByUsername(@InputArgument String username) {
        return userService.findUserByUsername(username);
    }
    @DgsQuery
    public UserDto userById(@InputArgument String id) {
        return userService.findUserById(Long.parseLong(id));
    }
    @DgsMutation
    public UserDto updateLastLogin(@InputArgument String username) {
        return userService.updateLastLogin(username);
    }
    @DgsMutation
    public UserDto createOrUpdateUser(@InputArgument String username) {
        return userService.createOrUpdateUser(username);
    }
}

================
File: user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/mapper/UserMapper.java
================
package com.glizzy.milliondollarpicks.userservice.mapper;
import com.glizzy.milliondollarpicks.userservice.dto.UserDto;
import com.glizzy.milliondollarpicks.userservice.entity.User;
import org.springframework.stereotype.Component;
@Component
public class UserMapper {
    public UserDto toDto(User user) {
        if (user == null) {
            return null;
        }
        return UserDto.builder()
                .id(user.getId())
                .username(user.getUsername())
                .registrationDate(user.getRegistrationDate())
                .lastLoginDate(user.getLastLoginDate())
                .build();
    }
}

================
File: user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/repository/UserRepository.java
================
package com.glizzy.milliondollarpicks.userservice.repository;
import com.glizzy.milliondollarpicks.userservice.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    boolean existsByUsername(String username);
}

================
File: user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/service/UserService.java
================
package com.glizzy.milliondollarpicks.userservice.service;
import com.glizzy.milliondollarpicks.userservice.dto.UserDto;
public interface UserService {
    UserDto findUserByUsername(String username);
    UserDto findUserById(Long id);
    UserDto updateLastLogin(String username);
    UserDto createOrUpdateUser(String username);
}

================
File: user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/service/UserServiceImpl.java
================
package com.glizzy.milliondollarpicks.userservice.service;
import com.glizzy.milliondollarpicks.userservice.dto.UserDto;
import com.glizzy.milliondollarpicks.userservice.entity.User;
import com.glizzy.milliondollarpicks.userservice.mapper.UserMapper;
import com.glizzy.milliondollarpicks.userservice.exception.UserNotFoundException;
import com.glizzy.milliondollarpicks.userservice.repository.UserRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.OffsetDateTime;
import lombok.RequiredArgsConstructor;
@Service
@RequiredArgsConstructor
@Transactional
public class UserServiceImpl implements UserService {
    private final UserRepository userRepository;
    private final UserMapper userMapper;
    @Override
    @Transactional(readOnly = true)
    public UserDto findUserByUsername(String username) {
        return userRepository.findByUsername(username)
                .map(userMapper::toDto)
                .orElseThrow(() -> new UserNotFoundException("User not found with username: " + username));
    }
    @Override
    @Transactional(readOnly = true)
    public UserDto findUserById(Long id) {
        return userRepository.findById(id)
                .map(userMapper::toDto)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + id));
    }
    @Override
    public UserDto updateLastLogin(String username) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UserNotFoundException("User not found with username: " + username));
        user.setLastLoginDate(OffsetDateTime.now());
        User savedUser = userRepository.save(user);
        return userMapper.toDto(savedUser);
    }
    @Override
    public UserDto createOrUpdateUser(String username) {
        return userRepository.findByUsername(username)
                .map(existingUser -> userMapper.toDto(userRepository.save(existingUser)))
                .orElseGet(() -> {
                    User newUser = new User();
                    newUser.setUsername(username);
                    newUser.setRegistrationDate(OffsetDateTime.now());
                    return userMapper.toDto(userRepository.save(newUser));
                });
    }
}

================
File: user-service/src/main/java/com/glizzy/milliondollarpicks/userservice/UserServiceApplication.java
================
package com.glizzy.milliondollarpicks.userservice;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
@SpringBootApplication
@EnableConfigurationProperties
public class UserServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }
}

================
File: user-service/src/main/resources/application-docker.yml
================
spring:
  datasource:
    url: jdbc:postgresql://postgres:5432/userdb
    username: ${SPRING_DATASOURCE_USERNAME:postgres}
    password: ${SPRING_DATASOURCE_PASSWORD:postgres}
    driver-class-name: org.postgresql.Driver
  jpa:
    hibernate:
      ddl-auto: validate
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true
    show-sql: true
  flyway:
    url: ${SPRING_FLYWAY_URL:jdbc:postgresql://postgres:5432/userdb}
    user: ${SPRING_FLYWAY_USER:postgres}
    password: ${SPRING_FLYWAY_PASSWORD:postgres}
    baseline-on-migrate: true
    locations: classpath:db/migration
logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql: TRACE
    com.glizzy.milliondollarpicks: DEBUG
    org.springframework.boot: INFO
grpc:
  client:
    auth-service:
      host: auth-service
      port: 9090

================
File: user-service/src/main/resources/application.yml
================
spring:
  datasource:
    url: jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:userdb}
    username: ${DB_USERNAME:postgres}
    password: ${DB_PASSWORD:postgres}
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: true
    properties:
      hibernate:
        format_sql: true
  flyway:
    baseline-on-migrate: true
    locations: classpath:db/migration
dgs:
  graphql:
    enabled: true
  graphiql:
    enabled: true
    path: /graphiql
logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql: TRACE
    com.glizzy.milliondollarpicks: DEBUG
grpc:
  client:
    auth-service:
      host: localhost
      port: 9090

================
File: user-service/src/main/resources/db/migration/V1__init_user_schema.sql
================
CREATE TABLE IF NOT EXISTS users (
     id SERIAL PRIMARY KEY,
     username VARCHAR(50) NOT NULL UNIQUE,
     password VARCHAR(255) NOT NULL,
     registration_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
     last_login_date TIMESTAMP
);

================
File: user-service/src/main/resources/db/migration/V2__update_id_to_bigserial.sql
================
ALTER TABLE users DROP CONSTRAINT users_pkey;
ALTER TABLE users
    ALTER COLUMN id TYPE BIGINT,
    ALTER COLUMN id SET DEFAULT nextval('users_id_seq'::regclass);
ALTER TABLE users ADD PRIMARY KEY (id);

================
File: user-service/src/main/resources/db/migration/V3__remove_password_field.sql
================
ALTER TABLE users DROP COLUMN password;

================
File: user-service/src/main/resources/schema/schema.graphqls
================
scalar DateTime

type Query {
    userById(id: ID!): User
    userByUsername(username: String!): User
}

type Mutation {
    updateLastLogin(username: String!): User
    createOrUpdateUser(username: String!): User
}

type User {
    id: ID!
    username: String!
    registrationDate: DateTime
    lastLoginDate: DateTime
}


================================================================
Instruction
================================================================
{
    "output": {
        "instructionFilePath": "repomix-instruction.md",
        "removeComments": true
    }
}
